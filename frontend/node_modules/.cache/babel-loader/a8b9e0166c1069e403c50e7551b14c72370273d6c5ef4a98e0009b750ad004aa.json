{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nimport SockJS from 'sockjs-client';\nimport { Client } from '@stomp/stompjs';\nconst useWebSocket = () => {\n  _s();\n  const client = useRef(null);\n  const [messages, setMessages] = useState([]);\n  const [connected, setConnected] = useState(false);\n  const [error, setError] = useState(null);\n  const [retryCount, setRetryCount] = useState(0);\n  const maxRetries = 5;\n  useEffect(() => {\n    const url = 'http://localhost:9092/ws/progress';\n    const connect = () => {\n      client.current = new Client({\n        brokerURL: undefined,\n        webSocketFactory: () => new SockJS(url),\n        reconnectDelay: 5000,\n        debug: str => {\n          console.log(str);\n        }\n      });\n      client.current.onConnect = () => {\n        setConnected(true);\n        setError(null);\n        setRetryCount(0);\n        console.log('STOMP connected');\n        client.current.subscribe('/topic/progress', message => {\n          if (message.body) {\n            setMessages(prev => [...prev, message.body]);\n            console.log('Received message:', message.body);\n          }\n        });\n      };\n      client.current.onStompError = frame => {\n        setConnected(false);\n        setError('STOMP error: ' + frame.message);\n        console.error('STOMP error:', frame);\n      };\n      client.current.onWebSocketClose = () => {\n        setConnected(false);\n        console.log('STOMP disconnected');\n        if (retryCount < maxRetries) {\n          setRetryCount(count => count + 1);\n          setTimeout(() => {\n            connect();\n          }, 2000);\n        } else {\n          setError('Max retry attempts reached. Connection failed.');\n        }\n      };\n      client.current.activate();\n    };\n    connect();\n    return () => {\n      if (client.current) {\n        client.current.deactivate();\n      }\n    };\n  }, [retryCount]);\n  const sendMessage = msg => {\n    if (client.current && client.current.connected) {\n      client.current.publish({\n        destination: '/app/progress',\n        body: msg\n      });\n    } else {\n      console.error('STOMP client is not connected');\n      setError('Cannot send message: STOMP client is not connected');\n    }\n  };\n  return {\n    connected,\n    messages,\n    sendMessage,\n    error\n  };\n};\n_s(useWebSocket, \"x1YBmqKgddxCVvJKf/ePnAn4S5I=\");\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","SockJS","Client","useWebSocket","_s","client","messages","setMessages","connected","setConnected","error","setError","retryCount","setRetryCount","maxRetries","url","connect","current","brokerURL","undefined","webSocketFactory","reconnectDelay","debug","str","console","log","onConnect","subscribe","message","body","prev","onStompError","frame","onWebSocketClose","count","setTimeout","activate","deactivate","sendMessage","msg","publish","destination"],"sources":["C:/Users/sivas/My Project/QuickLAN/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\r\nimport SockJS from 'sockjs-client';\r\nimport { Client } from '@stomp/stompjs';\r\n\r\nconst useWebSocket = () => {\r\n  const client = useRef(null);\r\n  const [messages, setMessages] = useState([]);\r\n  const [connected, setConnected] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [retryCount, setRetryCount] = useState(0);\r\n  const maxRetries = 5;\r\n\r\n  useEffect(() => {\r\n    const url = 'http://localhost:9092/ws/progress';\r\n\r\n    const connect = () => {\r\n      client.current = new Client({\r\n        brokerURL: undefined,\r\n        webSocketFactory: () => new SockJS(url),\r\n        reconnectDelay: 5000,\r\n        debug: (str) => {\r\n          console.log(str);\r\n        },\r\n      });\r\n\r\n      client.current.onConnect = () => {\r\n        setConnected(true);\r\n        setError(null);\r\n        setRetryCount(0);\r\n        console.log('STOMP connected');\r\n\r\n        client.current.subscribe('/topic/progress', (message) => {\r\n          if (message.body) {\r\n            setMessages((prev) => [...prev, message.body]);\r\n            console.log('Received message:', message.body);\r\n          }\r\n        });\r\n      };\r\n\r\n      client.current.onStompError = (frame) => {\r\n        setConnected(false);\r\n        setError('STOMP error: ' + frame.message);\r\n        console.error('STOMP error:', frame);\r\n      };\r\n\r\n      client.current.onWebSocketClose = () => {\r\n        setConnected(false);\r\n        console.log('STOMP disconnected');\r\n        if (retryCount < maxRetries) {\r\n          setRetryCount((count) => count + 1);\r\n          setTimeout(() => {\r\n            connect();\r\n          }, 2000);\r\n        } else {\r\n          setError('Max retry attempts reached. Connection failed.');\r\n        }\r\n      };\r\n\r\n      client.current.activate();\r\n    };\r\n\r\n    connect();\r\n\r\n    return () => {\r\n      if (client.current) {\r\n        client.current.deactivate();\r\n      }\r\n    };\r\n  }, [retryCount]);\r\n\r\n  const sendMessage = (msg) => {\r\n    if (client.current && client.current.connected) {\r\n      client.current.publish({ destination: '/app/progress', body: msg });\r\n    } else {\r\n      console.error('STOMP client is not connected');\r\n      setError('Cannot send message: STOMP client is not connected');\r\n    }\r\n  };\r\n\r\n  return { connected, messages, sendMessage, error };\r\n};\r\n\r\nexport default useWebSocket;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}